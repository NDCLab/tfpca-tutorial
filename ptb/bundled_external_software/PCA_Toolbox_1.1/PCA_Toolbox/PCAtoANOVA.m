function PCAtoANOVA(loadings, scores, varSD, PCAmode, baseline, numchans, timepoints, scalebins, numsubs, changrps, inputcells, startwin, endwin, dig, measure, factor, fname, stand);%  PCAtoANOVA(loadings, scores, varSD, PCAmode, baseline, numchans, timepoints, scalebins, numsubs, changrps, inputcells, startwin, endwin, dig, measure, factor, fname, stand) - generates summary measures for ANOVAs from PCA results%%  Outputs text file suitable for ANOVA from PCA results.  Each line is a subject.  As for columns, cells will vary slowest while chan groups will%  vary fastest.  Chan groups will be generated for spatial as well as temporal PCAs even though chan effects will not occur for spatial PCAs.%  Results will be in microvolts (or msec) for a specific channel (or mean of group of channels) for a specific window to make results exactly comparable%  to conventional analyses.%%Inputs:%  loadings	: Factor pattern matrix - produces standardized variables from scores, scaled by communality  (variables, factors)%  scores 	: is a factor score matrix (observations, factors)  Observations should vary with cell the slowest, followed by subject, and then chan/point the fastest.%  varSD    : Standard deviations of the variables.%  PCAmode	: 'spat' for spatial PCA or 'temp' for temporal PCA%  baseline	: Latency of first timepoint in msec. (first loading for temporal PCA or first score for spatial PCA)%  numchans : Number of channels%  timepoints : Number of timepoints%  scalebins : Number of bins per microvolt%  numsubs	: Number of subjects%  changrps : Channel going into each output channel grouping (channel group, channels).  Should be padded with zeros to maximum number of input chans.%				Example:%					changrps = [6 8 0 0;...%					1 2 3 4];% inputcells : Cells included in analysis.  Should be specified in order desired for output.% startwin   : Start of time window in samples (1-based).% endwin	 : End of time window in samples.% dig	     : Number of msec. per sample.% measure	 : Type of measure for windows: mean, minpeak, maxpeak, minlatency, maxlatency, mincentroid, maxcentroid.% factor	 : Factor to be output% fname		 : name of output file% stand      : Whether to scale the data or leave standardized  ('st'=standardized, 'sc'=scaled).  If standardized, different factors can be compared.  If not, it's in microvolts.%History:%  Matlab 5.2.1%  by Joseph Dien (4/4/01)%  University of Kansas%  jdien@ku.edu%%  modified 10/4/01 JD%  Added ability to output standardized factor scores so that different factors can be compared within a single ANOVA.%%  modified 11/19/02 JD%  Added error message for when Endwindow is larger than timepoints.  Latency output in milliseconds rather than samples.%%  modified 11/24/02 JD%  Added centroid option to types of measures.%%  bugfix 5/29/05 JD%  Fixed channel groups feature for spatial PCAs%%  modified 11/9/06 JD%  added error check for stand variable%%     Copyright (C) 1999-2008  Joseph Dien% %     This program is free software: you can redistribute it and/or modify%     it under the terms of the GNU General Public License as published by%     the Free Software Foundation, either version 3 of the License, or%     (at your option) any later version.% %     This program is distributed in the hope that it will be useful,%     but WITHOUT ANY WARRANTY; without even the implied warranty of%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the%     GNU General Public License for more details.% %     You should have received a copy of the GNU General Public License%     along with this program.  If not, see <http://www.gnu.org/licenses/>.if endwin < startwin	error('Endwindow sample is smaller than startwindow sample.');end;if endwin > timepoints	error('Endwindow sample is larger than number of time points.');end;if nargin < 18  stand = 'SC';endif length(stand) ~= 2    error('stand parameter must equal either SC for scaled or ST for standardized');end;if stand == 'SC'	loadings=diag(varSD)*loadings/scalebins;	%prepare for conversionelseif stand == 'ST'	loadings=ones(size(loadings,1),size(loadings,2)); %set to ones so that the scores are output still standardizedelse	error('stand parameter must equal either SC for scaled or ST for standardized');endoutputdata = zeros(numsubs,(size(changrps,1)*length(inputcells)));if PCAmode == 'temp'	for subject = 1:numsubs		for cell = 1:length(inputcells)		    for group = 1:size(changrps,1)				data = 0;				count = 0;				for withingrp = 1:size(changrps,2)					if changrps(group, withingrp) ~= 0						data = data + scores(((inputcells(cell)-1)*numsubs*numchans)+((subject-1)*numchans)+changrps(group, withingrp),factor);						count = count +1;					end;				end;				data = data /count;				outputdata(subject,(cell-1)*size(changrps,1)+group) = data;			end;		end;	end;	switch measure		case 'mean', outputdata = mean(loadings(startwin:endwin,factor)).*outputdata;		case 'minpeak', outputdata = min(loadings(startwin:endwin,factor)).*outputdata;		case 'maxpeak', outputdata = max(loadings(startwin:endwin,factor)).*outputdata;		case 'minlatency', [dummy, latency] = min(loadings(startwin:endwin,factor)); outputdata = ones(numsubs,(size(changrps,1)*length(inputcells))).*(latency * dig) + baseline;		case 'maxlatency', [dummy, latency] = max(loadings(startwin:endwin,factor)); outputdata = ones(numsubs,(size(changrps,1)*length(inputcells))).*(latency * dig) + baseline;        case 'mincentroid',            epoch=loadings(startwin:endwin,factor);            maxvalue=max(epoch);            outputdata = sum([startwin:endwin]'.*(epoch-maxvalue)/sum(epoch-maxvalue)).*outputdata*dig + baseline;        case 'maxcentroid',            epoch=loadings(startwin:endwin,factor);            minvalue=min(epoch);            outputdata = sum([startwin:endwin]'.*(epoch-minvalue)/sum(epoch-minvalue)).*outputdata*dig + baseline;		otherwise, error('Measure should be one of the following options: mean, minpeak, maxpeak, minlatency, maxlatency, mincentroid, maxcentroid');	end;        elseif PCAmode == 'spat'	for subject = 1:numsubs		for cell = 1:length(inputcells)		    for group = 1:size(changrps,1)				data = 0;				count = 0;				for withingrp = 1:size(changrps,2)					if changrps(group, withingrp) ~= 0						data = data + loadings(changrps(group, withingrp), factor);						count = count +1;					end;				end;				data = data /count;				startscore = ((inputcells(cell)-1)*numsubs*timepoints)+((subject-1)*timepoints)+startwin;				endscore = ((inputcells(cell)-1)*numsubs*timepoints)+((subject-1)*timepoints)+endwin;				switch measure					case 'mean', outputdata(subject,(cell-1)*size(changrps,1)+group) = mean(scores(startscore:endscore,factor))*data;					case 'minpeak', outputdata(subject,(cell-1)*size(changrps,1)+group) = min(scores(startscore:endscore,factor))*data;					case 'maxpeak', outputdata(subject,(cell-1)*size(changrps,1)+group) = max(scores(startscore:endscore,factor))*data;					case 'minlatency', [dummy, latency] = min(scores(startscore:endscore,factor)); outputdata(subject,(cell-1)*size(changrps,1)+group) = (latency * dig) + baseline;					case 'maxlatency', [dummy, latency] = max(scores(startscore:endscore,factor)); outputdata(subject,(cell-1)*size(changrps,1)+group) = (latency * dig) + baseline;                    case 'mincentroid',                        epoch=scores(startscore:endscore,factor);                        maxvalue=max(epoch);                        outputdata(subject,(cell-1)*size(changrps,1)+group) = sum([startwin:endwin]'.*(epoch-maxvalue)/sum(epoch-maxvalue))*dig + baseline;                    case 'maxcentroid',                        epoch=scores(startscore:endscore,factor);                        minvalue=min(epoch);                        outputdata(subject,(cell-1)*size(changrps,1)+group) = sum([startwin:endwin]'.*(epoch-minvalue)/sum(epoch-minvalue))*dig + baseline;                    otherwise, error('Measure should be one of the following options: mean, minpeak, maxpeak, minlatency, maxlatency, mincentroid, maxcentroid');                end;			end;		end;	end;else	error('PCAmode should be either ''temp'' for temporal or ''spat'' for spatial');end;eval(['save ' fname ' outputdata -ASCII -TABS;']);