function [erp] = combine_files(innames,outname,reduce_text,rsrate,preprocessing) 
%  [erp] = combine_files(innames[,outname][,reduce_text][,rsrate]) 
% 
% combine files - requires identical samplerate, tbin, elecnames, domain, and stim variables 
%                 The primary use for this is to combine trial or average files, that are  
%                 identical in every respect, except having different subjects.  
% 
%           NOTE: To combine files that have the same subjects (e.g. from different conditions),  
%                 use combine_files, then apply combine_files_consolodate_subnums to reconcile 
%                 subject numbers  
% 
% Parameters: 
%   innames     - see below 
%   outname     - file to write, omit or [], for do not write file.   
%   reduce_text - when present, and not empty, calls reduce_erp with reduce_text (see that funciton for reduce_text examples) 
%   rsrate      - when present, new samplerate for file 
%   preprocessing - optional string: either script name, or series of commands. 
%                   Executed on each file before combining (could include reduce_erp 
%                   or resampling here instead of reduce_text or rsrate parameters) 
%  
% Use with Average or Trial files generated by the toolbox 
% 
% Example innames:  
% 
%   Example 1: 
%  
%   innames = { ...
%    '/datapath1/sbjtrls_file1.mat'
%    '/datapath2/sbjtrls_file2.mat'
%              };
% 
%   Example 2: 
%  
%   erpbig(1,:).erp = erp1; 
%   erpbig(2,:).erp = erp2;  
%   innames = erpbig; 
% 
% Command Examples: 
% 
%   1 - combine_files(innames,'sbjtrls_combined.mat'); 
%   2 - combine_files(innames,'sbjtrls_combined.mat','erp.correct==1');
% 
% Command Example Descriptions: 
% 
%   1 - Simple combining 
%   2 - Simple combining with reduction of the dataset be some criterion (e.g. correct trials only):  
% 
%   NOTE: also works with component score files -- 'components' variable (as of) 
%         Use 'erp' in reduce text -- as if it were an 'erp' variable 
% 
% Psychophysiology Toolbox - Data Processing, Edward Bernat, University of Minnesota  

% args 

% vars 
set = []; 
erpt = []; 
new_subnum = []; 
cur_subnum = 0; 

for s = 1:length(innames(:,1)),

  if ~isstruct(innames),
    cur_name = char(innames(s,:));
%   disp(['Loading: ' cur_name ]);
    load(cur_name);
  else  
    cur_name = num2str(s); 
%   disp(['Processing: ' cur_name ]);
    erp = innames(s).erp; 
  end 

  if exist('components','var'), 
    erp = components; 
    clear components;  
    data_type = 'components'; 
  elseif exist('erptfd','var'), 
    erp = erptfd;
    clear erptfd;
    data_type = 'erptfd';
  else  
    data_type = 'erp'; 
  end

  % reduce if requested 
  if exist('reduce_text','var')==1, 
    if ~isempty(reduce_text), 
      erp = reduce_erp(erp,reduce_text); 
    end 
  end

  % resample if requested  
    if exist('rsrate','var'),
      if isfield(erp,'data'), 
        if ~isempty(rsrate) && ~isequal(rsrate,0) && ~isequal(rsrate,erp.samplerate),
          if isfield(erp,'domain') || isequal(erp.domain,'time'), 
%           if verbose > 0, disp(['Resample data to ' num2str(rsrate) 'Hz']); end
            erp.data = resample(erp.data',rsrate,erp.samplerate)';
            erp.tbin = floor((erp.tbin-1) * (rsrate/erp.samplerate)) +1;
            erp.samplerate=rsrate; 
          end  
        else, 
          disp(['  WARNING:' mfilename ': rsrate only valid for time domain data -- resample not performed']);
        end 
      else  
          disp(['  WARNING:' mfilename ': rsrate undefined for components datafile -- resample not performed']); 
      end 
    end

  % external processing interface 1 
    if exist('preprocessing','var') && ~isempty(preprocessing) && ~isequal(preprocessing,0),
      if exist(preprocessing,'file'),
        disp(['Executing external preprocessing script: ' preprocessing ]);
        try,   run(preprocessing);
        catch, disp('ERROR: preprocessing file not found -- NO preprocessing script executed');
        end
      else,
        disp(['     ' mfilename ':Executing inline preprocessing script: ' preprocessing ]);
        try,   eval(preprocessing);
        catch, disp('ERROR: preprocessing inline script failed -- NO preprocessing script executed');
               disp('ERROR text: ');
               disp(lasterr);
        end
      end
    end

  % if it's 1st file, use basic parameters from that file (tbin, samplerate, etc) 
  if s == 1,  
    erpt = erp; 

    % error check 
    if isfield(erp,'data'),
      if isfield(erpt,'scaled2uV'),
        if erp.scaled2uV==0, 
          disp(['  WARNING:' mfilename ': data NOT scaled to microvolts for: ' cur_name ', scaling can not be recovered']); 
        end 
      end 
    end 

    % create set number 
    set = ones(size(erpt.elec))*s;

    % handle main variables 
    if isfield(erp,'components'),
      compnames = fieldnames(erp.components);
      for sn = 1:length(compnames),
        cur_compname = char(compnames(sn,:));
        eval(['erpt.components.' cur_compname '=[erpt.components.' cur_compname ';];' ]);
      end
    end 
    if isfield(erp,'data'),
    erpt.data     = [     erpt.data ;]; 
    end 
    erpt.elec     = [     erpt.elec ;];
    erpt.sweep    = [    erpt.sweep ;];
    if isfield(erp,'subnum'), 
       new_subnum = erpt.subnum; 
    else
       cur_subnum = 1;
       new_subnum = ones(size(erp.elec));
    end 
    if isfield(erp,'subs'),
       cur_subnum = length(erp.subs.name(:,1));  
    end
    erpt.subnum   = []; 
    erpt.ttype    = [    erpt.ttype ;];
    erpt.correct  = [  erpt.correct ;];
    erpt.accept   = [   erpt.accept ;];
    erpt.rt       = [       erpt.rt ;];
    erpt.response = [ erpt.response ;];

    % deal with subs.name variable 
    if isfield(erp,'subs'),
    else  
      erpt.subs.name = cur_name; 
    end

    % deal with .stim variables 
    if isfield(erp,'stim'),
      stimnames = fieldnames(erp.stim);
      for sn = 1:length(stimnames),
        cur_stimname = char(stimnames(sn,:));
        eval(['erpt.stim.' cur_stimname '=[erpt.stim.' cur_stimname ';];' ]);
      end
    end 

    clear erp

  % if not 1st file, store in erpt 
  else   

    % error check 
    if isfield(erp,'data'),
      if ~isequal(size(erpt.data(1,:,:)),size(erp.data(1,:,:))) | ... 
         ~isequal(erpt.tbin      ,erp.tbin      ) | ...
         ~isequal(erpt.samplerate,erp.samplerate),
        disp(['  ERROR:' mfilename ': data size, tbin, or samplerate parameters for ' cur_name ' not identical to previous files -- ABORTING']);
        erp = 0;
        return
      end 
    end 
    if isfield(erp,'components'),
      if ~isequal(fieldnames(erpt.components),fieldnames(erp.components)),
        disp(['  ERROR:' mfilename ': components for ' cur_name ' not identical to previous files -- ABORTING']);
        erp = 0;
        return
      end
    end 
    if isfield(erp,'stim'),
      if ~isequal(fieldnames(erpt.stim),fieldnames(erp.stim)),
        disp(['  ERROR:' mfilename ': stim values for ' cur_name ' not identical to previous files -- ABORTING']);
        erp = 0;
        return
      end
    end
    if ~isequal(erpt.elecnames ,erp.elecnames ), 
       disp(['  ERROR:' mfilename ': elecname for ' cur_name ' not identical to previous files -- ABORTING']); 
       erp = 0;  
       return   
    end 
    if isfield(erp,'data'),
      if isfield(erpt,'scaled2uV'),  
        if erp.scaled2uV==0, 
          disp(['  WARNING:' mfilename ': data NOT scaled to microvolts for: ' cur_name ', scaling can not be recovered']); 
        end 
      end 
    end

    % create set number 
    set = [set; ones(size(erp.elec))*s];

    % handle main variables 
    rowidx_start = length(erpt.elec)+1; 
    rowidx_end   = length(erpt.elec)+length(erp.elec);  
    if isfield(erp,'components'),
      compnames = fieldnames(erp.components);
      for sn = 1:length(compnames),
        cur_compname = char(compnames(sn,:));
        eval(['erpt.components.' cur_compname '(rowidx_start:rowidx_end,:) = erp.components.' cur_compname ';' ]);
      end
    end
    if isfield(erp,'data'),
        erpt.data(rowidx_start:rowidx_end,:,:) = erp.data; erp.data = [];             % more memory efficient  
%   erpt.data     = [erpt.data    ;     erp.data ;]; erp.data = [];                 % less memory efficient  
    end 
        erpt.elec(rowidx_start:rowidx_end,:) = erp.elec  ;
       erpt.sweep(rowidx_start:rowidx_end,:) = erp.sweep ;
    if isfield(erp,'subnum'),
      new_subnum(rowidx_start:rowidx_end,:) = erp.subnum + cur_subnum;  
      cur_subnum = cur_subnum + length(erp.subs.name(:,1));
    else 
      cur_subnum    = cur_subnum+1;
       new_subnum(rowidx_start:rowidx_end,:)  = ones(size(erp.elec)) * cur_subnum;   
    end
       erpt.ttype(rowidx_start:rowidx_end,:) =  erp.ttype;
     erpt.correct(rowidx_start:rowidx_end,:) =  erp.correct;
      erpt.accept(rowidx_start:rowidx_end,:) =  erp.accept;
          erpt.rt(rowidx_start:rowidx_end,:) =  erp.rt;
    erpt.response(rowidx_start:rowidx_end,:) =  erp.response;

    % deal with subs.name variable 
    if isfield(erp,'subs'),
      if iscell(erpt.subs.name) || iscell(erp.subs.name), 
        erpt.subs.name = [erpt.subs.name; erp.subs.name;];
      else,  
        erpt.subs.name = strvcat(erpt.subs.name,erp.subs.name);  
      end  
    else  
      erpt.subs.name = strvcat(erpt.subs.name,cur_name);   
    end

    % handle stim variable if present 
    if isfield(erp,'stim'),
      stimnames = fieldnames(erp.stim);
      for sn = 1:length(stimnames),
        cur_stimname = char(stimnames(sn,:));
        eval(['erpt.stim.' cur_stimname '(rowidx_start:rowidx_end,:) = erp.stim.' cur_stimname ';' ]);
      end
    end 

    clear erp 

  end 

end

erpt.subnum = new_subnum; 
erpt.set    = set;  
% rename erp 
erp = erpt;
clear erpt;

% save out file 
if exist('outname','var'), 
  if ~isempty(outname), 
    disp(['Saving: ' outname ]);
    switch data_type, 
    case 'components', 
      components = erp; 
      save(outname,'components'); 
    case 'erptfd',
      erptfd = erp;
      save(outname,'erptfd');
    case 'erp', 
      save(outname,'erp');
    end  
  end 
end 
 
