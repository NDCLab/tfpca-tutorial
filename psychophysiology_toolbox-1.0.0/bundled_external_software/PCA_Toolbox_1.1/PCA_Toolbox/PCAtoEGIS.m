function [peakLatency, peakSamp, peakChan, facWaves] = PCAtoEGIS(PCAmode, cnames, cellcoll, ename, base, numchan, timePoints, numSubs, SampleRate, bins, cal, fname, scores, loadings, varSD, exclChan, output, subs, params, paramNames);% PCAtoEGIS - [peakLatency, peakSamp, peakChan, facWaves] = PCAtoEGIS(data, indexdata, PCAmode, cnames, cellcoll, ename, base, numchan, timePoints, numSubs, SampleRate, bins, cal, fname, scores, loadings, varSD exclChan,, output, subs, params, paramNames); - output PCA results to an EGIS file%Inputs%  PCAmode	 : Format for output data ('temp': time points as columns; 'spat': channels as columns).%  cnames	 : Cell array of cell names.%  cellcoll	 : Cell array of which input cells are going into each output cell (output cell, input cells).  %				Example:%					Cells = {[6 8];...%					[1 2 3 4]};%  ename	 : Name of the experiment.%  base		 : Size of baseline in msec. for EGIS file header%  numchan	 : Number of channels.%  timePoints: Number of timepoints.%  numSubs   : Number of subjects.%  SampleRate: Number of samples obtained per second.%  bins		 : Scale bins (number of arbitrary bins per microvolt)%  cal		 : Calibration scale%  fname	 : File name of output EGIS file.  If it is empty, then a requestor dialog box will appear.%  scores 	 : is the standardized factor score matrix (observations, factors)%  loadings	 : Factor pattern matrix - produces standardized variables from scores, scaled by communality  (variables, factors)%  exclChan	 : Channels not to be reported as peak channel (typically eye channels and midline channels)%  varSD     : Standard deviations of the variables.%  output	 : Form of output.  'EGI' = EGIS format.  'MAT' = matlab format.%               EGIS format output files are automatically changed to 500 bins per microvolt%               so that saving in integer format does not lose too much resolution.%  subs      : 'SUBS' = separate output files for each subject.  'GAVE' = single grand average output file.%%                   -----Optional------%  params    : parameters to correlate against factor results to produce parametric PCA solutions (weights, parameter).%              The rows should correspond to input cells and subjects (e.g., [C1S1; C1S2; C2S1; C2S2]).%              Rows with a value of 999 will be dropped.%  paramNames: Cell array of parameter names.%%Outputs%  peakLatency:	Peak latencies (absolute microvolts) in msec, minus the baseline period.  (cells, factors)%  peakSamp:	Peak latencies (absolute microvolts) in samples.  (cells, factors)%  peakChan:	Peak channel at peak latency (absolute microvolts), not including channels excluded by exclChan.  (cells, factors)%  facWaves:	Cell array of factor waves (factors, cells).  Only if output option is 'MAT'.  The last row contains the cell names.%%  Saves EGIS file with the factor results.  The factor scores and the factor pattern are multiplied to produce%  the portion of the grand average accounted for by the factoring.  The cells input array allows the output%  cells to be any desired combination of input cells.  In addition, a grand average of all the input cells is%  generated and added to the end of the EGIS file.  The observations are the factors.  In addition to the input%  factors, an additional observation is added to the end that is the total amount of the grand average accounted%  for by the factor analysis.  Optionally, may specify parameters that will be used for parametric PCA results,%  which will be output as additional cells.  Parametric cells contain the microvolt change corresponding to a one standard%  deviation change in the parameter.%  When using parametric PCA, also saves a .mat file with "Scores" appended to the name containing the%  scores matrix with factors*chans as cols and obs as rows to facilitate analysis.%  For when outputting separate subject files, parametric correlations calculated separately for each subject.%History%  Matlab 5.2.1%  by Joseph Dien (10/1/00)%  University of Kansas%  jdien@ku.edu%%  modified (1/9/01) JD%  Added parametric PCA option.%%  bugfix(1/10/01) JD%  Transpose spatial data blocks before writing out to disk.  Also, changed data input to varSD.%%  modified (2/27/01) JD%  Added peakLatency output.%%  modified (5/29/01) JD%  Added peakChan and peakSamp output.%%  corrected (8/22/01) JD%  Gave added to factor reconstructions to assist identification.%%  modified (2/2/02) JD%  Eliminated assumption that cell numbers of dataset are in ascending order.%%  modified (6/7/02) JD%  Also, modified to eliminate warning message when no exclusion channels.%%  modified (6/26/02) JD%  added option to output matlab matrices rather than EGIS file.%%  corrected (6/30/02) JD%  Fixed subject specs to include subject ID number so NetStation will label observations properly and NAvg so BESA will have N= info.%%  bugfix (7/9/02) JD%  Fixed bug in parametric PCA output.  Results were not being calculated properly.%%  upgraded (8/22/02) JD%  Changed to work under Matlab 6.5%%  modified (11/3/02) JD%  Missing number for parameter vectors is now 999.%%  bugfix (3/24/03) JD%  Eliminated x10 scaling in parametric PCA output.%%  bugfix & modified (4/25/03) JD%  Parametric output after first parametric cell was computed incorrectly.  Also,%  will change bins to 500 for EGI format output since losing too much resolution%  when bins equal 1 (as with NS output) since EGIS files are saved in integer format.%  Also now saves scores matrix when using parametric option.%%  modified (5/11/03) JD%  Added individual subject file output option.%% bugfix (5/1/04) JD% Fixed naming of scores .mat file%% bugfix (1/6/05) JD% Fixed fclose statement, individual file output option, and Mat output option.  Thanks to Robert Frank!%% modified (6/16/05) JD% Added error check for cell numbers.%% modified (11/15/05) JD% In parametric PCA procedure, drop cells corresponding to missing data% parameters when generating the mean voltage map.%% bugfix (12/9/07) JD% Fixed scaling error when input data is not 500 bins per microvolt%% modified (12/19/07) JD% Changed input cell names and parameter names arrays to cell arrays.% Changed cellcoll to cell array, thus eliminating need to pad it out with zeroes.% Deleted old filetype function (only worked on OS 9 Macs).% Eliminated indexdata.  Eliminated the +gave option.%% modified (1/27/08) JD% EGIS files always written as big-endian since NetStation makes this% assumption.%     Copyright (C) 1999-2008  Joseph Dien% %     This program is free software: you can redistribute it and/or modify%     it under the terms of the GNU General Public License as published by%     the Free Software Foundation, either version 3 of the License, or%     (at your option) any later version.% %     This program is distributed in the hope that it will be useful,%     but WITHOUT ANY WARRANTY; without even the implied warranty of%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the%     GNU General Public License for more details.% %     You should have received a copy of the GNU General Public License%     along with this program.  If not, see <http://www.gnu.org/licenses/>.if nargin < 19    params = [];    paramNames = [];endif (nargout < 4) & (output == 'MAT')    disp('Error - If output is set to be a Matlab matrix then an output matrix must be named');    return;end;if (output ~= 'MAT') & (output ~= 'EGI')    disp('Error - Output option must be set to either MAT or EGI');    return;end;if (subs ~= 'SUBS') & (subs ~= 'GAVE')    disp('Error - subs option must be set to either SUBS or NOSUBS');    return;end;if length(cnames) ~= length(cellcoll)    disp('Error - The number of Cell Names does not match the number of output cell specifications');    return;end;if length(paramNames) ~= size(params,2)    disp('Error - The number of Parameter Cell Names does not match the number of parameter output cell specifications');    return;end;cnames{length(cnames)+1} = 'all';for name =1:length(cnames)    temp=[cnames{name} blanks(80)];     cnames2(name,1:80)=temp(1:80);                                                                               end;if PCAmode == 'temp'    VarNum = timePoints;    ObsNum = numchan;elseif PCAmode == 'spat'    VarNum = numchan;    ObsNum = timePoints;else    error('PCAmode must be set to either temp or spat');end;if mod(size(scores,1),(ObsNum * numSubs)) ~= 0    disp('Error - The number of factor scores is not evenly divided by the number of subjects and the channels/time points.');    return;end;NumCell = size(scores,1)/(ObsNum * numSubs);	%Find number of cellsfor i = 1:size(cellcoll,1)    temp=cellcoll{i};    if (max(temp) > NumCell)        disp('Error - You have specified a cell number in cellcoll that does not exist.');        return;    end;    if (min(temp) < 1)        disp('Error - You have specified a cell number in cellcoll that is smaller than zero.');        return;    end;end;if ~isempty(params)    for name =1:length(paramNames)        temp=[paramNames{name} blanks(80)];         paramNames2(name,1:80)=temp(1:80);                                                                                   end;    cnames2 = [cnames2; paramNames2];    if size(params,1) ~= (size(scores,1)/ObsNum)        disp('Error - number of weights for each parameter needs to be equal to the number of subjects times cells');        return;    end;end;if size(cnames2,2) > 80    disp('Error - Cell Names are longer than the allowable 80 characters');    return;end;%Sum together factor scores across subjects in each cellNUM_FAC = size(scores,2);avgCells = zeros(ObsNum*NumCell,NUM_FAC);CellCount = zeros(NumCell,1);numSubSpecs = 14;for cellLoop = 1:NumCell    for sub = 1:numSubs        avgCells((cellLoop-1)*ObsNum+1:cellLoop*ObsNum,:) = avgCells((cellLoop-1)*ObsNum+1:cellLoop*ObsNum,:) + scores((cellLoop-1)*numSubs*ObsNum+(sub-1)*ObsNum+1:(cellLoop-1)*numSubs*ObsNum+sub*ObsNum,:);        CellCount(cellLoop) = CellCount(cellLoop)+1;    end;end;numOutputCells = size(cellcoll,1)+1;theLastDone = NUM_FAC+1;%Take a moment out to set up the output files now that the number of subjects has been established.numFiles = 1;if subs == 'SUBS'    numFiles = numSubs;end;if (output == 'EGI')    scores = scores * 500/bins; %Set bins to standard 500 per microvolt.    avgCells = avgCells * 500/bins; %Set bins to standard 500 per microvolt.    ave_hdr_offsets_v;    fhdr(BaseDur) = base;    fhdr(NChan) = numchan;    fhdr(ScaleBins) = 500;    fhdr(ScaleCal) = cal;    fcom = '';    ftext = '';    ename = [ename blanks(80)];    ename = ename(1,1:80);    if isempty(fname)        [fname, pathname] = uiputfile('*.*','Save As:');        if (isempty(fname))|(fname == 0)            error('No filename selected. You have to click on a name')        end        fname = [pathname fname];    end    for file = 1:numFiles        if subs == 'SUBS'            [fid(file), message]=fopen([fname 'S' num2str(file)],'w');        elseif subs == 'GAVE'            [fid(file), message]=fopen(fname,'w');        end;        if fid == -1            disp(message)            if message(1:5)=='Sorry'                disp('Error while trying to create the new output file.');                disp('One possible cause for the error is the use of a / in the file name which OS X interprets as a path separator.');            end;            return        end    end;elseif output == 'MAT'    facWaves=cell(theLastDone+1, numOutputCells, numFiles);end;%Divide by number of summed factor scores to produce mean factor scores for each cellwarning off MATLAB:divideByZerofor k = 1:NumCell    for i = 1:ObsNum        avgCells((k-1)*ObsNum+i,:) = avgCells((k-1)*ObsNum+i,:) / CellCount(k);    end;end;warning on MATLAB:divideByZero%start loop for each output filefor file = 1:numFiles    if subs == 'SUBS'   %if doing separate subject output files, need to redo the avgCells so only one subject at a time.        avgCells = zeros(ObsNum*NumCell,NUM_FAC);        obsPerSub = size(scores,1)/numSubs;        avgCells(1:ObsNum*NumCell,:)=scores(NumCell*(file-1)*ObsNum+1:file*NumCell*ObsNum,:);    end;    %Compute output cells by collapsing together cells according to cell specifications    OutCells = zeros((size(cellcoll,1)+2)*ObsNum,NUM_FAC);	%construct matrix of mean factor scores (output cells*chans/points,factors)    for i = 1:size(cellcoll,1)        Count = 0;        for j = 1:length(cellcoll{i})            if cellcoll{i}(j) ~= 0                for obs = 1:ObsNum                    OutCells((i-1)*ObsNum+obs,:) = OutCells((i-1)*ObsNum+obs,:) + avgCells((cellcoll{i}(j)-1)*ObsNum+obs,:);                end;                Count = Count +1;            end;        end;        for obs = 1:ObsNum            OutCells((i-1)*ObsNum+obs,:) = OutCells((i-1)*ObsNum+obs,:) / Count;        end;    end;    Count = 0;    for cellLoop = 1:NumCell        for obs = 1:ObsNum            OutCells((numOutputCells-1)*ObsNum+obs,:) = OutCells((numOutputCells-1)*ObsNum+obs,:) + avgCells((cellLoop-1)*ObsNum+obs,:);	%compute mean of all cells for 'total' cell        end;        Count = Count +1;    end;    for k = 1:ObsNum        OutCells((numOutputCells-1)*ObsNum+k,:) = OutCells((numOutputCells-1)*ObsNum+k,:) / Count;    end;    %Construct parametric PCA output if so instructed    if ~isempty(params)        %Compute correlations with factor scores        scoresMatrix = zeros((size(scores,1)/ObsNum),(ObsNum*NUM_FAC));        for i = 1:(size(scores,1)/ObsNum)            CellScores = scores((i-1)*ObsNum+1:i*ObsNum,:);	%cell's scores (chans, factors)            scoresMatrix(i,:) = reshape(CellScores, 1, prod(size(CellScores)));	%building matrix with factors*chans as cols and obs as rows        end;        if subs == 'GAVE'            eval(['save ' fname 'scores.mat scoresMatrix']);        elseif subs == 'SUBS'            eval(['save ' fname 'S' num2str(file) 'scores.mat scoresMatrix']);        end;        for i = 1:size(params,2)            index = find(params(:,i)~=999);	%observations with non-missing params and thus retained for correlation            correl = corrcoef([scoresMatrix(index,:) params(index,i)]);	%column vector of correlations            correl = correl(1:size(correl,2)-1,size(correl,2));	%extract just the correlations between the parameter and the chans (chans*factors)            corrMatrix = reshape(correl,ObsNum,NUM_FAC);	%matrix of correlations (chans,factors)            Count = 0;            parametricMean=zeros(ObsNum,NUM_FAC);            for cellLoop = 1:NumCell                if params(cellLoop,i)~=999	%generate mean ERP for parametric computation, not including missing data                    for obs = 1:ObsNum                        parametricMean(obs,:) = parametricMean(obs,:) + avgCells((cellLoop-1)*ObsNum+obs,:);	%compute mean of all cells                    end;                    Count = Count +1;                end;            end;            parametricMean=parametricMean/Count;            OutCells = [OutCells; parametricMean.*corrMatrix];	%add parametric PCA output cell        end;        numOutputCells=numOutputCells+size(params,2);    end;    if output == 'EGI'        fhdr(NCells) = numOutputCells;        fhdr(LastDone) = theLastDone;        %Construct cell headers        chdr = zeros(fhdr(NCells),(5+numSubSpecs*fhdr(LastDone)));        for i = 1:fhdr(NCells)            chdr(i,CellID) = 90 + i;            chdr(i,NObs) = fhdr(LastDone);            chdr(i,NPoints) = timePoints;            chdr(i,SampRate) = SampleRate;            chdr(i,LSpec) = numSubSpecs*2;            for k = 1:fhdr(LastDone)                chdr(i,numSubSpecs*(k-1)+SubjID_Ave)=k;                chdr(i,numSubSpecs*(k-1)+NAvg)=numSubs;            end;        end;        %Write out output data        [status]=wt_PCAave_hdr_v(fid(file),fhdr,chdr,ename,cnames2,fcom,ftext);	%Write header    end;    peakSamp=zeros(numOutputCells,NUM_FAC);    peakChan=zeros(numOutputCells,NUM_FAC);    fprintf('%60s\n',' ' );    for outcell = 1:numOutputCells        fprintf('%s%-60s',repmat(sprintf('\b'),1,60),sprintf('%s%4d%s%4d','Working on output cell# ', outcell))        sumblock = zeros(numchan, timePoints);        for factor = 1:NUM_FAC            datablock=[];            for Obs = 1:ObsNum	%chans for temporal or points for spatial                datablock(Obs,:) = OutCells((outcell-1)*ObsNum+Obs, factor)*loadings(:, factor)'*diag(varSD);            end;            if PCAmode == 'spat'                datablock = datablock';	%make so that rows are time points and columns are channels            end;            [x peakSamp(outcell, factor)] = max(sum(abs(datablock)));	%find (absolute) peak time.  x is a dummy variable.            [x chans] = sort(abs(datablock(:,peakSamp(outcell, factor))));	%find (absolute) peak chan.  x is a dummy variable.            topchan = length(chans);            if ~isempty(exclChan)                while ~isempty(find(exclChan == chans(topchan)))                    topchan = topchan -1;                    if topchan == 0                        error('All channels excluded from peakchan calculation.');                    end;                end;            end;            peakChan(outcell, factor)=chans(topchan);            if output == 'EGI'                fwrite(fid(file), int16(round(datablock)), 'int16','ieee-be');	%Write data            elseif output == 'MAT'                facWaves{factor, outcell, file} = datablock;            end;            sumblock=sumblock+datablock;        end;        if output == 'EGI'            fwrite(fid(file), int16(round(sumblock)), 'int16','ieee-be');	%Write totalled data        elseif output == 'MAT'            facWaves{theLastDone, outcell, file} = sumblock;            facWaves{theLastDone+1, outcell, file} = cnames2(outcell,:);        end;    end;    peakLatency = (peakSamp.*(1000/SampleRate))-base;  %Convert to msec.    if output == 'EGI'        r=fclose(fid(file));    end;end;if output ~= 'MAT'    facWaves = [];end;fprintf('%s\r',' ' );fprintf('%s\r','Done...' );