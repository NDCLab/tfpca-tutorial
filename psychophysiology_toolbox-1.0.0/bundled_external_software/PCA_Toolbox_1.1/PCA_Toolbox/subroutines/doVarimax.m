function [Ak, VmxScr]= doVarimax(A, VmxScr, KAISER);%[Ak, VmxScr]= doVarimax(A, VmxScr, KAISER);  - Compute varimax rotation for PCA%  Gives essentially identical results to SAS command: PROC FACTOR rot = varimax%%Inputs%  A		: Unrotated factor loadings matrix (variables, factors)%  VmxScr	: Unrotated factor scores%  KAISER	: Kaiser normalization ('K' Kaiser normalization, 'N' no Kaiser normalization, 'C' covariance loadings).%%Outputs%  Ak		: Rotated factor pattern matrix%  VmxScr	: Rotated factor scores%%History%%  Cureton, E. E. & Mulaik, S. A. (1975).  The weighted varimax rotation and the promax rotation.%  Psychometrika, 40(2) 183-195.%%  Kaiser, H. F. (1959).  Computer program for varimax rotation in factor analysis.%  Educational and Psychological Measurement, 19(3) 413-420.%%  Harman, H. H.  (1976).  Modern factor analysis, 3rd edition.  Chicago:University of Chicago Press.%%  by Joseph Dien (4/99)%  University of Kansas%  jdien@ku.edu%%  modified (9/30/00) JD%  Modified to allow Kaiser normalization to be turned off.%%  bugfix (2/27/01) JD%  Fixed bug in Kaiser correction code (not undoing it when turned on)%%  modified (3/1/01) JD%  Added direct rotation of factor scores.%%  bugfix (3/24/01) JD%  Factor scores reordered and flipped when factor loadings are.%%  modified (5/27/01) JD%  Factor scoring coefficients added.%%  modified (8/14/01) JD%  Deleted rotation of V to minimize effect of cumulative rounding errors%%  modified (7/26/02) JD%  Added non-convergence warning.%%  modified (10/22/02) JD%  Lowered minimum criteria for rotation to .00001 since Kaiser suggested%  .00116 was too loose and was sometimes not rotating when it should.%  Added warning if no rotation occurred.%%  modified (2/15/04) JD%  Added accomodation for covariance loading option%%  modified (01/09/05) JD and Dan Beal%  Added Weighted Varimax option (Cureton and Mulaik, 1975)%     Copyright (C) 1999-2008  Joseph Dien% %     This program is free software: you can redistribute it and/or modify%     it under the terms of the GNU General Public License as published by%     the Free Software Foundation, either version 3 of the License, or%     (at your option) any later version.% %     This program is distributed in the hope that it will be useful,%     but WITHOUT ANY WARRANTY; without even the implied warranty of%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the%     GNU General Public License for more details.% %     You should have received a copy of the GNU General Public License%     along with this program.  If not, see <http://www.gnu.org/licenses/>.MaxRotations = 1000;	%Maximum number of rotations to do before calling it a dayC = sum((A.^2)')';  %vector of communalitiesNUM_FAC = size(A,2);	%Number of factors retainedNUM_VAR = size(A,1);	%Number of variablesif KAISER == 'K'    Ak = (diag(sqrt(C).^-1)) * A;  %factor loadings Kaiser-normalized by communalitieselseif  KAISER == 'C'    Ak = A;elseif  KAISER == 'N'    Ak = A;elseif  KAISER == 'W'    Ak = (diag(sqrt(C).^-1)) * A;  %factor loadings Kaiser-normalized by communalities    facReflect=sign(Ak(:,1)) + (sign(Ak(:,1)) == 0);    Ak = diag(facReflect)*Ak;    wpt1 = acos(sqrt(1/NUM_FAC));    halfPi=pi/2;    for f3 = 1:NUM_VAR        ak1 = Ak(f3,1);        if ak1 >= sqrt(1/NUM_FAC)%if the first factor loading is greater than the cos of the angle between the test vector and its first axis...            w1 = cos(((wpt1 - acos(ak1))/wpt1) * halfPi)^2 + .001;        else            w1 = cos(((acos(ak1) - wpt1)/(halfPi-wpt1)) * halfPi)^2 + .001;        end;        w(f3,1) = w1;    end;    Ak = diag(w)*Ak;else    error('Kaiser normalization needs to be specified as K or N or C or W');end;%  Start rotationcounter = NUM_FAC * (NUM_FAC -1)/2;  %initialize counternrot = 0;	%initialize rotation counterrotstats = [];rotated = 0;while (counter > 0) & (nrot < MaxRotations)  %do rotations until has gone through all w/o rotating or exceeded max rotations.    for f1 = 1:(NUM_FAC-1)        for f2 = (f1 + 1):NUM_FAC            A1 = Ak(:,f1);            A2 = Ak(:,f2);            Ar = [A1 A2];            ru = A1.^2 - A2.^2;            rv = 2 * A1 .* A2;            rA = sum(ru);            rB = sum(rv);            rC = sum(ru.^2 - rv.^2);            rD = 2*sum(ru .* rv);            Fr = [VmxScr(:,f1) VmxScr(:,f2)];            NUM = rD - (2 * rA * rB)/NUM_VAR;            DEN = rC - (rA.^2 - rB.^2)/NUM_VAR;            if abs(NUM/DEN) > .00001 %(would rotation be enough to bother with?)                rotated = 1;                G = sqrt(NUM^2+DEN^2);	%Following computational variant due Wingersky (Harman, p. 294)                cos4phi = DEN/G;                cos2phi = sqrt((1+cos4phi)/2);                cosphi = sqrt((1+cos2phi)/2);                sinphi = sqrt((1-cos2phi)/2);                if NUM < 0                    sinphi = -abs(sinphi);                else                    sinphi = abs(sinphi);                end;                rot = [cosphi -sinphi; sinphi cosphi];                Ar = Ar * rot;                Ak(:,f1) = Ar(:,1);                Ak(:,f2) = Ar(:,2);                Fr = Fr * rot;                VmxScr(:,f1)=Fr(:,1);                VmxScr(:,f2)=Fr(:,2);                counter = NUM_FAC * (NUM_FAC -1)/2;            else                counter = counter -1; %no rotation occurred so reduce counter.            end;        end;    end;    nrot = nrot +1;	%Increment number of rotations.  It is expected that after a certain point just not worth it.end;if KAISER == 'K'    Ak =  diag(sqrt(C)) * Ak;  %renormalize factor loadings by communalitieselseif  KAISER == 'W'    Ak = inv(diag(w))*Ak;    Ak = diag(facReflect)*Ak;    Ak =  diag(sqrt(C)) * Ak;  %renormalize factor loadings by communalitiesend;temp = sum(Ak.^2);[temp, order] = sort (temp);temp2 = Ak;temp3 = VmxScr;for f1 = 1:NUM_FAC    Ak(:,f1) = temp2(:,order(f1));   %reorder factors in order of size    VmxScr(:,f1) = temp3(:,order(f1));   %reorder factor scores in order of sizeend;for f1 = 1:NUM_FAC    if sum(Ak(:,f1)) < 0	%flip factor loadings so mostly positive        Ak(:,f1) = Ak(:,f1) .* (-1);        VmxScr(:,f1) = VmxScr(:,f1) .* (-1);    end;end;Ak = fliplr(Ak);VmxScr = fliplr(VmxScr);if (nrot >= MaxRotations)    disp(['Warning - solution did not converge.']);end;if (rotated == 0)    disp(['Warning - no rotation occurred.']);end;